*vimshell.txt*	Powerful shell implemented by Vim script

Version: 10.0
Author : Shougo <Shougo.Matsu@gmail.com>
License: MIT license  {{{
    Permission is hereby granted, free of charge, to any person obtaining
    a copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:
    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
}}}

CONTENTS						*vimshell-contents*

Introduction		|vimshell-introduction|
Install			|vimshell-install|
Interface		|vimshell-interface|
  Commands		  |vimshell-commands|
  Variables		  |vimshell-variables|
  Functions		  |vimshell-functions|
  Key mappings		  |vimshell-key-mappings|
    Vimshell buffer key mappings    |vimshell-buffer-key-mappings|
    Interactive buffer key mappings |vimshell-interactive-buffer-key-mappings|
Examples		|vimshell-examples|
Internal Commands	|vimshell-internal-commands|
Special Commands	|vimshell-special-commands|
Alter Command		|vimshell-alter-command|
Hook			|vimshell-hook|
Tips			|vimshell-tips|
Unite sources		|vimshell-unite-sources|
Create plugin		|vimshell-create-plugin|
FAQ			|vimshell-faq|
Changelog		|vimshell-changelog|

==============================================================================
INTRODUCTION						*vimshell-introduction*

Vimshell is an extreme shell that doesn't depend on external shells but is
written completely in pure Vim script. To be honest the implementation is not
as mature as eshell yet. The most important characteristic of vimshell is that
it can collaborate with other Vim plugins. Additionally, for example, vimshell
also works on Windows where there are no good shells at all; note that you
cannot use full set of vimshell features on Windows though. Furthermore,
vimshell borrowed handy functionalities from other shells. Vimshell has
built-in functionalities that you had to set up to enable if it's on zsh.

Vimshell doesn't pursue being completely compatible with average shells but
aims to be a handy shell, so some behaviours like the rule of variables are a
little bit different to them.

==============================================================================
USAGE						*vimshell-usage*

You can start vimshell in ":VimShell", or use helpful keymap already defined.
Because vimshell works similar with a common shell, you may operate it
intuitively. But vimshell performs the path appointment in '/'.
Vimshell fails to recognize escape sequences when you use '\' on Windows
for a path and does not work.

vimshell reads .vimshrc as initialize file.
It might be helpful to add alias configurations.

Note: vimshell has nothing to do with bash or zsh, so as to have no
compatiblities.  vimshell doesn't read .bashrc or .zshrc, but environment
variables by "vimshell-internal-source".

==============================================================================
INSTALL						*vimshell-install*

vimshell depends on |vimproc|
http://github.com/Shougo/vimproc

You must install and compile vimproc Ver.5.0(or later) before using vimshell
(refer to |vimproc-install|).

Note: To enable all the features of vimshell, neocomplcache is required.
https://github.com/Shougo/neocomplcache

==============================================================================
INTERFACE					*vimshell-interface*

------------------------------------------------------------------------------
COMMANDS 					*vimshell-commands*

:VimShell [{options}...] [{path}]		*:VimShell*
		Runs vimshell. The {path} will be its current directory.
		If aother vimshell buffer exists, switches to the vimshell
		buffer and changes its current directory to {path}.
		If you omit {path}, it uses Vim's current directory (or does
		not change the current directory).

						*vimshell-options*
		{options} are options for a vimshell buffer.  You may give the
		following parameters for a option; you must escape with \ when
		it contains spaces.

						*vimshell-options-buffer-name*
		-buffer-name={buffer-name}
		Specifies a buffer name. The default buffer name is 'default'.
		Note: Buffer name must not contain spaces.

						*vimshell-options-toggle*
		-toggle
		Close vimshell buffer window if this vimshell buffer name
		window is exists.

						*vimshell-options-create*
		-create
		Create new vimshell buffer.

						*vimshell-options-split*
		-split
		Split vimshell buffer window. |vimshell-options-split-command|
		is used.

						*vimshell-options-popup*
		-popup
		Popup split vimshell buffer window.
		|vimshell-options-split-command| is used.

					*vimshell-options-split-command*
		-split-command={command-name}
		Specify split command.

						*vimshell-options-prompt*
		-prompt={prompt}
		Specify prompt string. If omit it,
		|g:vimshell_prompt| is used.

					*vimshell-options-secondary-prompt*
		-secondary-prompt={secondary-prompt}
		Specify secondary prompt string. If omit it,
		|g:vimshell_secondary_prompt| is used.

						*vimshell-options-user-prompt*
		-user-prompt={user-prompt}
		Specify secondary prompt string. If omit it,
		|g:vimshell_user_prompt| is used.

					*vimshell-options-right-prompt*
		-right-prompt={right-prompt}
		Specify right prompt string. If omit it,
		|g:vimshell_right_prompt| is used.

						*vimshell-options-project*
		-project
		Move to project directory.

:VimShellCreate [{options}...] [{path}]		*:VimShellCreate*
		Runs vimshell as the same :VimShell, but it creates a new
		vimshell buffer instead of activating other vimshells which
		are up and runnig.

:VimShellTab [{options}...] [{path}]		*:VimShellTab*
		It's same as |:VimShellCreate|, but creates a new tab.

:VimShellPop [{options}...] [{path}]		*:VimShellPop*
		Like as |:VimShell|, but this command popups little window.
		It will be your help when you want to make vimshell a bit
		help.  To split it, |g:vimshell_popup_command| is suited
		command.
		Note: It sets |vimshell-options-toggle|. You can toggle
		vimshell buffer.

:VimShellCurrentDir [{options}...] [{path}]	*:VimShellCurrentDir*
		Like as |:VimShell|, but move to current directory.

:VimShellBufferDir [{options}...] [{path}]	*:VimShellBufferDir*
		Like as |:VimShell|, but move to buffer's dirrectory.

:VimShellExecute {command}			*:VimShellExecute*
		It does not run vimshell, but launches a terminal program you
		Specify by {command}, and this program runs in background.
		You can use vimshell like as GNU screen.

:VimShellInteractive [{command}]		*:VimShellInteractive*
		It does not run vimshell, but launches a interpreter program
		you specify by {command}.  It is same as Emacs's M-x
		{interpreter-name}.  You leave out {command}, vimshell uses
		the value in |g:vimshell_interactive_interpreter_commands|.

		Resize window example:
>
		VimShellInteractive --split='split | resize 20' irb
<
:VimShellTerminal {command}			*:VimShellTerminal*
		It does not run vimshell, but same as Emacs's ansi-term,
		it launches a terminal program you Specify by {command}.
		Note: This is not completed function.

:[range]VimShellSendString {string}		*:VimShellSendString*
		It sends selected string to the interpreter in background
		buffer of vimshell, iexe, texe.  You can control interpreter
		as if you are using |quickrun|.
		Cf: |vimshell#interactive#send()|
		Note: If interpreter is not loaded in current tab, you can run
		interpreter command.

:VimShellSendBuffer {bufname}			*:VimShellSendBuffer*
		Sets background buffer as {bufname}.  When {bufname} isn't
		showed, it will be opened automatically.

------------------------------------------------------------------------------
VARIABLES 					*vimshell-variables*

g:vimshell_prompt				*g:vimshell_prompt*
		Sets vimshell default prompt string. Initial value is
		"vimshell%".

g:vimshell_secondary_prompt			*g:vimshell_secondary_prompt*
		Sets vimshell default secondary prompt string. Initial value
		is "%%".

g:vimshell_user_prompt				*g:vimshell_user_prompt*
		You can define additional prompt to substitute a string for
		this.  Unlike |g:vimshell_prompt|, it can be a non-fixed
		string.  You can get multi-line prompt by seperating "user
		prompt" with \n.

		This example will be helpful to show current directory
		everytime.
>
		let g:vimshell_user_prompt = 'getcwd()'
<
g:vimshell_right_prompt				*g:vimshell_right_prompt*
		It's zsh-like right prompt. This value is a string value which
		is an expression of Vim script. similar to
		|g:vimshell_user_prompt|, but this calculates the window size,
		and shows the prompt on preferable position.
		Initial value is empty.

g:vimshell_no_default_keymappings
					*g:vimshell_no_default_keymappings*
		Disables all default key mapings in vimshell.

		You can not use vimshell funcitons unless you set new
		key mappings, so it is for hackers who have understood the
		inner behaviors, and not recommended for newbies.

g:vimshell_use_terminal_command
					*g:vimshell_use_terminal_command*
		When executes |vimshell-internal-shell|, this option set
		terminal program execute shell.
		"ckw -e" in Windows, "gnome-terminal -e" in Linux,
		become a candidate of value.
		
		Initial value is "".

g:vimshell_temporary_directory		*g:vimshell_temporary_directory*
		Sets a temporaly directory used by vimshell. And history file
		is saved in this directory.

		Initial value is "expand('~/.vimshell')".

g:vimshell_max_command_history		*g:vimshell_max_command_history*
		Maximum number of entries in history.

		Initial value is 1000.

g:vimshell_max_directory_stack		*g:vimshell_max_directory_stack*
		Maximum number of directory stacks saved by vimshell.

		Initial value is 100.

g:vimshell_vimshrc_path				*g:vimshell_vimshrc_path*
		Sets a setting file read by vimshell first.
		This is similar to .bashrc in bash. It is convinience when you
		define aliases.

		Initial Value is "expand('~/.vimshrc')".

g:vimshell_escape_colors			*g:vimshell_escape_colors*
		A list of colors correspond to coloring in escape sequence.
		0-8 as normal colors, 9-15 as highlight colors.

		Initial value is written in plugin/vimshell.vim.

g:vimshell_disable_escape_highlight
					*g:vimshell_disable_escape_highlight*
		This value controls whether vimshell highlights escape
		sequences.  Disabling this function make vimshell faster
		because processing this is hard task.
		Note: This value is negative logic, so True means disabling.

		Default value is 0.

g:vimshell_cat_command				*g:vimshell_cat_command*
		Sets $PAGER command path.
		Note: This variable is useful for using pager comands.
		For example, "git log".
		Note: You *must not* set "core.pager" variable in your
		.gitconfig.
		
		Initial value is "cat".

g:vimshell_editor_command			*g:vimshell_editor_command*
		Sets $EDITOR command path.
		
		Note: This variable is useful for using editor comands.
		For example, "git commit" or "git rebase -i" commands.
		Note: This feature required GUI Vim and supported
		|+clientserver| feature.
		Note: To reflect external editor changes, you must write
		opened temporary buffer and execute|:bdelete| in external
		editor.
		Note: You *must not* set "core.editor" variable in your
		.gitconfig.

		Initial value "v:progname --servername=v:servername
		--remote-tab-wait-silent" or same to |g:vimshell_cat_command|.

g:vimshell_environment_term			*g:vimshell_environment_term*
		This value is $TERM on vimshell.
		Default value is "xterm".

g:vimshell_split_command			*g:vimshell_split_command*
		Vimshell uses this as the Ex command to split window.  If you
		set this "nicely", vimshell adjusts with the current window
		size and splits window preferable ("nicely" depends on the
		winwidth variable.)
		Empty means disabling window splitting on vimshell.
		"tabnew" means vimshell opens new tab.
		"vsplit" means vertical splitting.

		Default value is "nicely".

g:vimshell_popup_command			*g:vimshell_popup_command*
		Vimshell uses this as the Ex command to split window in
		|:VimShellPop|.
		If you leave this empty, vimshell uses "split" and
		|g:vimshell_popup_height|.

		Default value is "".

g:vimshell_popup_height				*g:vimshell_popup_height*
		This value is split height of |:VimShellPop|.
		This value is ratio percent against |winheight(0)|.
		Note: It is not used on non vimshell buffers (ex: interactive
		buffer.)

		Default value 30.

g:vimshell_cd_command				*g:vimshell_cd_command*
		This is the Ex command to change current directory.
		The command must interpret |`=|.

		Default value is "lcd".

g:vimshell_no_save_history_commands
					*g:vimshell_no_save_history_commands*
		This is a dictionary value that has keys of the command name
		that vimshell doesn't save in history.

		Default value is {'history': 1, 'h': 1, 'histdel': 1}.

g:vimshell_scrollback_limit			*g:vimshell_scrollback_limit*
		This value is the maximum size of command output.  Output
		buffer will be trim down if output is more than this value.

		Default value is 1000.

g:vimshell_enable_transient_user_prompt
				*g:vimshell_enable_transient_user_prompt*
		If it is non-zero, vimshell will delete user prompt and right
		prompt line after executing |<Plug>(vimshell_enter)| .

		Default value is 0.

g:vimshell_interactive_no_save_history_commands
			*g:vimshell_interactive_no_save_history_commands*
		This is a dictionary value which key is a command name that
		won't be save on the history in |vimshell-internal-iexe|.
		If there does not exist, it will be ignored.

		Default value is {}.

g:vimshell_interactive_update_time
					*g:vimshell_interactive_update_time*
		When |vimshell-internal-iexe| is in Insert mode, this value
		controls the timing of auto update.
		|vimshell-internal-iexe| changes 'updatetime' based on this
		value.

		Default value is 500.

g:vimshell_interactive_command_options
				*g:vimshell_interactive_command_options*
		This is a dictionary variable with command name key.  The
		command |vimshell-internal-iexe| runs take this as its option.
		This option is used in such situation that you want to use a
		command that take some particular options or doesn't work well
		interactively, like in windows environments.

		Defalut value is too complicated, so please refer
		autoload/vimshell/commands/iexe.vim.

g:vimshell_interactive_interpreter_commands
				*g:vimshell_interactive_interpreter_commands*
		This is a dictionary variable with filetype key and it is
		assignments of an interpreter name without arguments of
		|:VimShellInteractive|.

		Defalut value is too complicated, so please refer
		autoload/vimshell/commands/iexe.vim.

g:vimshell_interactive_encodings
					*g:vimshell_interactive_encodings*
		This is a dictionary variable with command name key and it is
		assignments of an encoding for the command which vimshell
		runs.
		If the key contains "/", vimshell will check if command path
		matches it.

		Defalut value is complicated, so please refer
		autoload/vimshell/plugin/vimshell.vim.

g:vimshell_interactive_echoback_commands
				*g:vimshell_interactive_echoback_commands*
		This is a dictionary variable with interpreter name key, and
		if the value is 1, iexe doesn't echoback when
		|vimshell-internal-iexe| is running, and otherwise
		does.
		This value has effect only on windows.

		Defalut value is complicated, so please refer
		plugin/vimshell.vim

g:vimshell_terminal_cursor			*g:vimshell_terminal_cursor*
		It is an assignment of cursor shape |vimshell-internal-texe|
		uses.  'guicursor' is temporary changed, so this value has
		effect only on
		gvim environments.

		Default value is 'i:block-Cursor/lCursor'.

g:vimshell_terminal_commands			*g:vimshell_terminal_commands*
		This is a dictionary variable with command name key, and when
		you run a command of which value is True, automatically
		|vimshell-internal-texe| is used.  iexe doesn't echoback when
		|vimshell-internal-iexe| is running, and otherwise
		does.

		Defalut value is complicated, so please refer
		autoload/vimshell/commands/iexe.vim.

g:vimshell_interactive_cygwin_commands
				*g:vimshell_interactive_cygwin_commands*
		This is a dictionary variable with command name key, and the
		value is an assignment of commands which runs via fakecygpty.
		It is used when you launch some application that works only on
		Cygwin (like ssh) by |vimshell-internal-iexe|.

		To know about fakecygpty, you should refer
		|vimshell-tips-fakecygpty|.

		Defalut value is complicated, so please refer
		autoload/vimshell/commands/iexe.vim.

g:vimshell_interactive_cygwin_path
					*g:vimshell_interactive_cygwin_path*
		It is assigned to the pass vimshell reffers when launching
		programs via fakecygpty.
		If the first argument of |vimshell-internal-iexe| is
		fakecygpty, vimshell searches command from
		|g:vimshell_interactive_cygwin_path|
		instead of $PATH.

		Default value is 'c:/cygwin/bin'.

g:vimshell_interactive_cygwin_home
					*g:vimshell_interactive_cygwin_home*
		It is assigned to $HOME of the program launched via
		fakecygpty.  Leavin '' means to use current $HOME.

		Default value is ''.

g:vimshell_interactive_monochrome_commands
				*g:vimshell_interactive_monochrome_commands*
		This is a dictionary variable with command name key, and the
		value is an assignment of commands which you want to disable
		hilighting.

		Defalut value is complicated, so please refer
		autoload/vimshell/commands/iexe.vim.

g:unite_source_vimshell_external_history_path	*g:unite_source_vimshell_external_history_path*
		It is assignment of a history file that
		|vimshell/external_history| source recognizes.

		Default value is set to suit for $SHELL value.

------------------------------------------------------------------------------
KEY MAPPINGS 					*vimshell-key-mappings*

<Plug>(vimshell_split_switch)		*<Plug>(vimshell_split_switch)*
		Split screen and switches vimshell buffer.

<Plug>(vimshell_split_create)		*<Plug>(vimshell_split_create)*
		Split screen and creates vimshell buffer.

<Plug>(vimshell_switch)				*<Plug>(vimshell_switch)*
		Switches to vimshell buffer.

<Plug>(vimshell_create)				*<Plug>(vimshell_create)*
		Create vimshell buffer.

VIMSHELL BUFFER KEY MAPPINGS 			*vimshell-buffer-key-mappings*

Normal mode key mappings.

<Plug>(vimshell_enter)				*<Plug>(vimshell_enter)*
		Execute command line.

<Plug>(vimshell_previous_prompt)
					*<Plug>(vimshell_previous_prompt)*
		Move to previous prompt from cursor.

<Plug>(vimshell_next_prompt)			*<Plug>(vimshell_next_prompt)*
		Move to next prompt from cursor.

<Plug>(vimshell_delete_previous_output)
				*<Plug>(vimshell_delete_previous_output)*
		Delete previous output form cursor.

<Plug>(vimshell_paste_prompt)		*<Plug>(vimshell_paste_prompt)*
		Paste cursor line to last prompt.

<Plug>(vimshell_move_end_argument)
					*<Plug>(vimshell_move_end_argument)*
		Move to command end argument.

<Plug>(vimshell_hide)				*<Plug>(vimshell_hide)*
		Hide vimshell buffer.

<Plug>(vimshell_exit)				*<Plug>(vimshell_exit)*
		Quit vimshell buffer.

<Plug>(vimshell_change_line)			*<Plug>(vimshell_change_line)*
		Change whole line.

<Plug>(vimshell_delete_line)			*<Plug>(vimshell_delete_line)*
		Delete whole line.

<Plug>(vimshell_hangup)				*<Plug>(vimshell_hangup)*
		Terminate command.

<Plug>(vimshell_insert_head)			*<Plug>(vimshell_insert_head)*
<Plug>(vimshell_insert_enter)
					*<Plug>(vimshell_insert_enter)*
<Plug>(vimshell_append_enter)
					*<Plug>(vimshell_append_enter)*
<Plug>(vimshell_append_end)			*<Plug>(vimshell_append_end)*
		Enter insert mode.

<Plug>(vimshell_clear)				*<Plug>(vimshell_clear)*
		Redraw vimshell buffer.

<Plug>(vimshell_move_head)			*<Plug>(vimshell_move_head)*
		Move to head.

<Plug>(vimshell_execute_by_background)
				*<Plug>(vimshell_execute_by_background)*
		Execute command by iexe.

Visual mode key mappings.
<Plug>(vimshell_select_previous_prompt)
				*v_<Plug>(vimshell_select_previous_prompt)*
		Select previous prompt from cursor.

<Plug>(vimshell_select_next_prompt)
				*v_<Plug>(vimshell_select_next_prompt)*
		Select next prompt from cursor.

Insert mode key mappings.

<Plug>(vimshell_command_complete)
					*i_<Plug>(vimshell_command_complete)*
		Start completion.
		Note: Required neocomplcache plugin.
		https://github.com/Shougo/neocomplcache

<Plug>(vimshell_zsh_complete)		*i_<Plug>(vimshell_zsh_complete)*
		Start completion using zsh.
		Note: Required zsh and unite plugin.
		https://github.com/Shougo/neocomplcache
		Note: It is not worked in Windows!

<Plug>(vimshell_push_current_line)
					*i_<Plug>(vimshell_push_current_line)*
		Push current line command to command line stack.

<Plug>(vimshell_insert_last_word)
					*i_<Plug>(vimshell_insert_last_word)*
		Insert command last word.

<Plug>(vimshell_run_help)			*i_<Plug>(vimshell_run_help)*
		View internal command help.

<Plug>(vimshell_move_head)			*i_<Plug>(vimshell_move_head)*
		Move to line head.

<Plug>(vimshell_delete_backward_line)
				*i_<Plug>(vimshell_delete_backward_line)*
		Delete backward line from cursor.

<Plug>(vimshell_delete_backward_word)
				*i_<Plug>(vimshell_delete_backward_word)*
		Delete backward word from cursor.

<Plug>(vimshell_enter)				*i_<Plug>(vimshell_enter)*
		Execute command.

<Plug>(vimshell_interrupt)			*i_<Plug>(vimshell_interrupt)*
		Send interrupt.

<Plug>(vimshell_move_previous_window)
				*i_<Plug>(vimshell_move_previous_window)*
		Move to previous window.

<Plug>(vimshell_delete_backward_char)
				*i_<Plug>(vimshell_delete_backward_char)*
<Plug>(vimshell_another_delete_backward_char)
			*i_<Plug>(vimshell_another_delete_backward_char)*
		Delete backward char from cursor.

<Plug>(vimshell_delete_forward_line)
				*i_<Plug>(vimshell_delete_forward_line)*
		Delete forward line from cursor.

<Plug>(vimshell_clear)				*i_<Plug>(vimshell_clear)*
		Redraw vimshell buffer.

<Plug>(vimshell_execute_by_background)
				*i_<Plug>(vimshell_execute_by_background)*
		Execute command by iexe.

<Plug>(vimshell_hide)				*i_<Plug>(vimshell_hide)*
		Hide vimshell buffer.

<Plug>(vimshell_exit)				*i_<Plug>(vimshell_exit)*
		Quit vimshell buffer.

Normal mode default key mappings.
{lhs}			{rhs}
--------		-----------------------------
<CR>			<Plug>(vimshell_enter)
q			<Plug>(vimshell_hide)
Q			<Plug>(vimshell_exit)
<C-p>			<Plug>(vimshell_previous_prompt)
<C-n>			<Plug>(vimshell_next_prompt)
<C-k>			<Plug>(vimshell_delete_previous_output)
<C-y>			<Plug>(vimshell_paste_prompt)
E			<Plug>(vimshell_move_end_argument)
cc			<Plug>(vimshell_change_line)
dd			<Plug>(vimshell_delete_line)
I			<Plug>(vimshell_insert_head)
A			<Plug>(vimshell_append_end)
i			<Plug>(vimshell_insert_enter)
a			<Plug>(vimshell_append_enter)
^			<Plug>(vimshell_move_head)
<C-c>			<Plug>(vimshell_hangup)
<C-l>			<Plug>(vimshell_clear)
<C-z>			<Plug>(vimshell_execute_by_background)

Visual mode default key mappings.
{lhs}			{rhs}
--------		-----------------------------
<C-p>			<Plug>(vimshell_select_previous_prompt)
<C-n>			<Plug>(vimshell_select_next_prompt)

Insert mode default key mappings.
{lhs}			{rhs}
--------		-----------------------------
<CR>			<Plug>(vimshell_enter)
<C-l>			Start vimshell/history source
<TAB>			<Plug>(vimshell_command_complete)
<C-a>			<Plug>(vimshell_move_head)
<C-u>			<Plug>(vimshell_delete_backward_line)
<C-w>			<Plug>(vimshell_delete_backward_word)
<C-z>	(while execute)	<Plug>(vimshell_execute_by_background)
	(other)		<Plug>(vimshell_push_current_line)
<C-t>			<Plug>(vimshell_insert_last_word)
<C-x><C-h>		<Plug>(vimshell_run_help)
<C-c>			<Plug>(vimshell_interrupt)
<C-h>			<Plug>(vimshell_delete_backward_char)
<BS>			<Plug>(vimshell_delete_backward_char)
<C-k>			<Plug>(vimshell_delete_forward_line)
<C-x>			<Plug>(vimshell_move_previous_window)

VIMSHELL INTERACTIVE BUFFER KEY MAPPINGS 
				*vimshell-interactive-buffer-key-mappings*

Normal mode key mappings.

<Plug>(vimshell_int_execute_line)
					*<Plug>(vimshell_int_execute_line)*
		Execute cursor line.

<Plug>(vimshell_int_previous_prompt)
					*<Plug>(vimshell_int_previous_prompt)*
		Move to previous prompt from cursor.

<Plug>(vimshell_int_next_prompt)
					*<Plug>(vimshell_int_next_prompt)*
		Move to next prompt from cursor.

<Plug>(vimshell_int_paste_prompt)
					*<Plug>(vimshell_int_paste_prompt)*
		Paste cursor line to last prompt.

<Plug>(vimshell_int_hangup)			*<Plug>(vimshell_int_hangup)*
		Exit executing command.

<Plug>(vimshell_int_exit)			*<Plug>(vimshell_int_exit)*
		Exit interactive buffer.

<Plug>(vimshell_int_restart_command)
					*<Plug>(vimshell_int_restart_command)*
		Restart command.

<Plug>(vimshell_int_change_line)
					*<Plug>(vimshell_int_change_line)*
		Change whole line.

<Plug>(vimshell_int_delete_line)
					*<Plug>(vimshell_int_delete_line)*
		Delete whole line.

<Plug>(vimshell_int_insert_enter)
					*<Plug>(vimshell_int_insert_enter)*
<Plug>(vimshell_int_insert_head)
					*<Plug>(vimshell_int_insert_head)*
<Plug>(vimshell_int_append_enter)
					*<Plug>(vimshell_int_append_enter)*
<Plug>(vimshell_int_append_end)
					*<Plug>(vimshell_int_append_end)*
		Enter insert mode.

<Plug>(vimshell_int_clear)			*<Plug>(vimshell_int_clear)*
		Redraw interactive buffer.

Insert mode key mappings.

<Plug>(vimshell_int_move_head)
					*i_<Plug>(vimshell_int_move_head)*
		Move to line head.

<Plug>(vimshell_int_delete_backward_line)
				*i_<Plug>(vimshell_int_delete_backward_line)*
		Delete backward line from cursor.

<Plug>(vimshell_int_delete_backward_word)
				*i_<Plug>(vimshell_int_delete_backward_word)*
		Delete backward word from cursor.

<Plug>(vimshell_int_execute_line)
					*i_<Plug>(vimshell_int_execute_line)*
		Execute current line.

<Plug>(vimshell_int_delete_backward_char)
				*i_<Plug>(vimshell_int_delete_backward_char)*
<Plug>(vimshell_int_another_delete_backward_char)
			*i_<Plug>(vimshell_int_another_delete_backward_char)*
		Delete backward character from cursor.

<Plug>(vimshell_int_send_input)
					*i_<Plug>(vimshell_int_send_input)*
		Send user input.

<Plug>(vimshell_int_interrupt)
					*i_<Plug>(vimshell_int_interrupt)*
		Send interrupt to command.

<Plug>(vimshell_int_command_complete)
				*i_<Plug>(vimshell_int_command_complete)*
		Start completion.

<Plug>(vimshell_int_delete_forward_line)
				*i_<Plug>(vimshell_int_delete_forward_line)*
		Delete forward line from cursor.

Normal mode default key mappings.
{lhs}			{rhs}
--------		-----------------------------
<C-p>			<Plug>(vimshell_int_previous_prompt)
<C-n>			<Plug>(vimshell_int_next_prompt)
<CR>			<Plug>(vimshell_int_execute_line)
<C-y>			<Plug>(vimshell_int_paste_prompt)
<C-z>			<Plug>(vimshell_int_restart_command)
<C-c>			<Plug>(vimshell_int_interrupt)
q			<Plug>(vimshell_int_exit)
cc			<Plug>(vimshell_int_change_line)
dd			<Plug>(vimshell_int_delete_line)
I			<Plug>(vimshell_int_insert_head)
A			<Plug>(vimshell_int_append_end)
i			<Plug>(vimshell_int_insert_enter)
a			<Plug>(vimshell_int_append_enter)
<C-l>			<Plug>(vimshell_int_clear)

Insert mode default key mappings.
{lhs}			{rhs}
--------		-----------------------------
<C-h>			<Plug>(vimshell_int_delete_backward_char)
<BS>			<Plug>(vimshell_int_delete_backward_char)
<C-a>			<Plug>(vimshell_int_move_head)
<C-u>			<Plug>(vimshell_int_delete_backward_line)
<C-w>			<Plug>(vimshell_int_delete_backward_word)
<C-k>			<Plug>(vimshell_int_delete_forward_line)
<CR>			<Plug>(vimshell_int_execute_line)
<C-c>			<Plug>(vimshell_int_interrupt)
<C-l>			Start vimshell/history source
<C-v>			<Plug>(vimshell_int_send_input)
<C-n>			<C-n>
<TAB>			Select candidate or start completion

------------------------------------------------------------------------------
FUNCTIONS 						*vimshell-functions*

vimshell#interactive#send({expr})
					*vimshell#interactive#send()*
		It sends {expr} to the interpreter in background buffer of
		vimshell, iexe, texe.  You can control interpreter as if you
		are using |quickrun|.
		{expr} is string or list.
		Note: If interpreter is not loaded in current tab, you can run
		interpreter command.

vimshell#interactive#send_string({expr})
					*vimshell#interactive#send_string()*
		Deprecated. Use |vimshell#interactive#send()| instead; they
		are equivalent.


vimshell#hook#set({hook-point}, {func-list})		*vimshell#hook#set()*
		Defines hook functions {func-list} in {hook-point}. The old
		hook points are overwrite.  Vimshell call {func-list} by list
		order.

vimshell#hook#get({hook-point})				*vimshell#hook#get()*
		Returns {hook-point} hook as dictionary.

vimshell#hook#add({hook-point}, {hook-name}, {func})
							*vimshell#hook#add()*
		Add {hook-name} hook {func} in {hook-point}. If {hook-name} is
		already exists, overwrite it.

vimshell#hook#remove({hook-point}, {hook-name})
						*vimshell#hook#remove()*
		Delete {hook-name} function in {hook-point}.

==============================================================================
EXAMPLES						*vimshell-examples*
>
	let g:vimshell_user_prompt = 'fnamemodify(getcwd(), ":~")'
	"let g:vimshell_right_prompt = 'vcs#info("(%s)-[%b]", "(%s)-[%b|%a]")'
	let g:vimshell_enable_smart_case = 1
	
	if has('win32') || has('win64')
	  " Display user name on Windows.
	  let g:vimshell_prompt = $USERNAME."% "
	else
	  " Display user name on Linux.
	  let g:vimshell_prompt = $USER."% "
	
	  call vimshell#set_execute_file('bmp,jpg,png,gif', 'gexe eog')
	  call vimshell#set_execute_file('mp3,m4a,ogg', 'gexe amarok')
	  let g:vimshell_execute_file_list['zip'] = 'zipinfo'
	  call vimshell#set_execute_file('tgz,gz', 'gzcat')
	    call vimshell#set_execute_file('tbz,bz2', 'bzcat')
	endif
	
	" Initialize execute file list.
	let g:vimshell_execute_file_list = {}
	call vimshell#set_execute_file('txt,vim,c,h,cpp,d,xml,java', 'vim')
	let g:vimshell_execute_file_list['rb'] = 'ruby'
	let g:vimshell_execute_file_list['pl'] = 'perl'
	let g:vimshell_execute_file_list['py'] = 'python'
	call vimshell#set_execute_file('html,xhtml', 'gexe firefox')
	
	autocmd FileType vimshell
	\ call vimshell#altercmd#define('g', 'git')
	\| call vimshell#altercmd#define('i', 'iexe')
	\| call vimshell#altercmd#define('l', 'll')
	\| call vimshell#altercmd#define('ll', 'ls -l')
	\| call vimshell#hook#add('chpwd', 'my_chpwd', 'g:my_chpwd')
	
	function! g:my_chpwd(args, context)
	  call vimshell#execute('ls')
	endfunction
	
	autocmd FileType int-* call s:interactive_settings()
	function! s:interactive_settings()
	endfunction
<
==============================================================================
INTERNAL COMMANDS					*vimshell-internal-commands*

The internal commands are internal commands in other shells.  The arguments are
split by vimshell.

Note: The internal commands do not supports pipeline.
If you use pipe, vimshell execute external command forcibly.  So following
commands will be freeze.
>
		vimshell% echo hello | vim
<
bg [{option}...] {command}				*vimshell-internal-bg*
		Opens new buffer and executes {command} by background.
		Execute external command forcibly.  You can not input to
		{command}.
		If you press <C-c> in background buffer, kill {command}
		execution.
		Note: "command &" equals to "bg command"
>
		vimshell% ls&
<
		Note: iexe, exe, bg, texe and less interpret options changes
		the behavior. Refer to |vimshell-execute-options|.
		
		--filetype={filetype-name}
		Changes output buffer 'filetype' to {filetype-name}.
		If omit the option, filetype will be set "background".

		--split={split-command}
		Specify split command.
		If omit this option, used |g:vimshell_split_command|.

build [{builder-name}, [{args}...]]			*vimshell-internal-build*
		Execute ":Unite build:{builder-name}:{args}".
		If you omit {builder-name}, detect builder automatically.

cd {directory-path} [{substitute-pattern}]		*vimshell-internal-cd*
		Changes current directory to {directory-path}. If omit
		arguments, change directory to $HOME.
		If you set {substitute-pattern}, substitute {directory-path} to
		{substitute-pattern}.
		If {directory-path} is not directory, change to file parent
		directory.
		If {directory-path} is not found, search 'cdpath'.
		If {directory-path} starts "-", same to
		|vimshell-internal-popd|.

clear 							*vimshell-internal-clear*
		Clear display.

dirs [{max}]						*vimshell-internal-dirs*
		Print directory stack items to {max} .
		If omit {max}, used 10.
		If press <Enter> in directory stack, change directory.

echo [{argument}...]				*vimshell-internal-echo*
		print arguments.

eval {expression}				*vimshell-internal-eval*
		Eval {expression} as vimshell script and print it.

exe [{option}...] {command} 			*vimshell-internal-exe*
		Execute {command} with arguments. Execute external command
		forcibly.
		Note: While executing commands, can not execute other
		commands.
		Note: After vimshell Ver.9, exe can read inputs.
		
		Note: iexe, exe, bg, texe and less interpret options changes
		the behavior. Refer to |vimshell-execute-options|.
		
						*vimshell-execute-options*
		--encoding={encoding-name}
					*vimshell-execute-options-encoding*
		If differnt from 'encoding' and {encoding-name}, vimshell will
		convert encoding automatically.
		If omit this option, used "char".

exit 						*vimshell-internal-exit*
		Exit vimshell buffer.

gcd [{directory-path}]				*vimshell-internal-gcd*
		Changes current directory and Vim current directory.
		If omit {directory-path}, move to Vim current directory.

gendoc {command} {args}				*vimshell-internal-gendoc*
		Executes {command} with {args} and saves output in
		"g:vimshell_temporary_directory/cached-doc". You can read
		cached outputs using |echodoc|.
		Note: This command caches first output line only.

gexe {command}					*vimshell-internal-gexe*
		Execute {command} with args. Execute external command
		forcibly.
		Differnt from exe, it is specialized GUI command.

h [{pattern}]						*vimshell-internal-h*
		Executes {pattern} matched history. If {pattern} is number,
		execute {pattern} number history.  If {pattern} is string,
		execute first {pattern} matched history.  You can check
		history number by executing |vimshell-internal-history|. If
		you omit {pattern}, execute last command.
		Note: This command does not add history.

histdel {history-number}			*vimshell-internal-histdel*
		Deletes {history-number} history. You can check history number
		using |vimshell-internal-history| command.

history [{search-string}]			*vimshell-internal-history*
		Print directory stack {search-string} items.
		If omit {search-string}, use 20. If {search-string} is string,
		print matched string candidates.
		If press <Enter> in history list, execute the history.

iexe [{options}...] {command}			*vimshell-internal-iexe*
		Opens new interactive buffer and execute {command} with args.
		Execute external command forcibly.
		Different from exe, this command is for interactive command.
		Note: Interactive buffer |filetype| is int-{command}. If you
		use |:autocmd| for interactive buffer, use "int-*" pattern.

		Note:
		This command does not support zsh's right-side prompt.
		If you execute a process from iexe, this sets "$VIMSHELL" 1.
		You may want to check it in your shell's rc file.

		Note: iexe, exe, bg, texe and less interpret options to change
		their behaviours. Refer |vimshell-execute-options|.

		--split={split-command}
		Specifies split command.
		If you omit this option, this uses |g:vimshell_split_command|.

less [{options}...] {command}			*vimshell-internal-less*
		Opens new buffer and executes {command} with arguments.
		Execute external command forcibly. Vimshell will work like
		pager.
		Note: syntax sugar:
		{command1} | {command2} | less
		If {command} is not executable command, execute
		|vimshell-internal-view|.
		
		Note: iexe, exe, bg, texe and less interpret options changes
		the behavior. Refer to |vimshell-execute-options|.

		--split={split-command}
		Specify split command.
		If omit this option, used |g:vimshell_split_command|.

ls [{argument}...]					*vimshell-internal-ls*
		Execute "ls" external command with args.
		Note: Required external "ls" command.

mkcd {directory-name}				*vimshell-internal-mkcd*
		Make {directory-name} directory and |vimshell-internal-cd| it.

nop 						*vimshell-internal-nop*
		No operation.

open {filename}					*vimshell-internal-open*
		Open {filename} by associated application.

popd [{directory-stack-number}]
						*vimshell-internal-popd*
		Change current directory to {directory-stack-number}
		directory.  To view {directory-stack-number}, use
		|vimshell-internal-dirs|.  If omit {directory-stack-number},
		used 0.
		Note: If differnt from other shells, do not remove not
		duplicated candidates.

pwd 						*vimshell-internal-pwd*
		Print vimshell working directory.

repeat {cnt} {command}				*vimshell-internal-repeat*
		Execute {command} {cnt} times.

shell 						*vimshell-internal-shell*
		Execute 'shell' commands using
		|g:vimshell_use_terminal_command|.  This command can support
		some features not supported vimshell.  Ex: signal and trap.

source {files}
						*vimshell-internal-source*
		Load {files} using "cmd.exe" in Windows, 'shell' in others.
		The {files} is shell script which changes environment
		variables.  After executed the command, vimshell will use
		changed environment variables.
		Note: This internal command is for ":source file" only.
		Note: This internal command is not used for virtualenv.
		Because virtualenv uses shell function.

source_shellcmd {shellcmd} [{args}]
					*vimshell-internal-source_shellcmd*
		Load {shellcmd} using "cmd.exe" in Windows, 'shell' in others.
		The {shellcmd} is shell command which changes environment
		variables.  After executed the command, vimshell will use
		changed environment variables.
		
		Note: The {shellcmd} must be executable from |system()|. You
		may edit .zshenv/.bashenv.

sudo {command} [{args}]				*vimshell-internal-sudo*
		Execute super user command. If {command} is "vim", this uses
		|sudo.vim|.
		http://www.vim.org/scripts/script.php?script_id=729
		On Windows, "sudo.exe" is necessary.
		http://bitbucket.org/wantora/sudo/wiki/Home

texe [{options}...] {command}			*vimshell-internal-texe*
		Execute {command} with args.
		Note: Execute external command forcibly.
		Differnt from exe and iexe, it execute terminal command.  This
		command creates new buffer.
		Note: Pipe is not supported.
		
		Note: This command is under construction.
		
		Note: iexe, exe, bg, texe and less interpret options changes
		the behavior. Refer to |vimshell-execute-options|.

		--split={split-command}
		Specify split command.
		If omit this option, used |g:vimshell_split_command|.

time {command}					*vimshell-internal-time*
		Runs {command} synchronously and shows how long did it take.

view [{options}...] {filenames}...
						*vimshell-internal-view*
		Opens {filenames} in other buffer as readonly. If lines is
		less than window size, do not open another buffer.
		
		--split={split-command}
		Specify split command.
		If omit this option, used |g:vimshell_split_command|.

vi [{options}...] [{filenames}...]			*vimshell-internal-vi*
		Same as |vimshell-internal-vim|.

vim [{options}...] [{filenames}...]
						*vimshell-internal-vim*
		Opens {filenames} in other buffer.  If omit {filenames}, opens
		unnamed buffer.

		--split={split-command}
		Specify split command.
		If omit this option, used |g:vimshell_split_command|.

vimdiff {filename1} {filename2}			*vimshell-internal-vimdiff*
		Compares {filename1} and {filename2} by |:vimdiff|command.

		--split={split-command}
		Specify split command.
		If omit this option, used |g:vimshell_split_command|.

vimsh [{filename}]				*vimshell-internal-vimsh*
		Execute {filename} vimshell script file.
		Note: Statements is not supported.
		If omit {filename}, opens new vimshell buffer.

which {command}					*vimshell-internal-which*
		Print {command} as full path. The command supports alias.

whereis {command}				*vimshell-internal-whereis*
		Print {command} by full path.

==============================================================================
SPECIAL COMMANDS				*vimshell-special-commands*
Special command is minimum parsed by vimshell. So, you can parse arguments in
special commands. But parsing is difficult.

alias {alias-name} = {command}			*vimshell-special-alias*
		Defines alias. Vimshell replaces {alias-name} as {command}.
		Differnt from other shells, "=" with spaces is valid.
		
		The alias can take arguments. To get arguments, use $$args
		variable.
>
		vimshell% alias echo=':echo "$$args"'
		vimshell% alias echo2=':echo "$$args[1]"'
		vimshell% alias echo3=':echo "$$args[2:]"'
<
galias {global-alias-name} = {command}
						*vimshell-internal-galias*
		Defines global alias. Vimshell replaces {global-alias-name} as
		{command}.  Differnt from |vimshell-special-alias|, global
		alias in arguments is expanded. This feature is like to zsh
		global alias.
		
		Note: Global alias with pipes is not supported.
>
		vimshell% galias G = '|grep'
		vimshell% ls G hoge
<
let ${var-name} = {expression}				*vimshell-special-let*
		Assigns {expression} to {var-name}.
		You must add prefix "$" in {var-name} head.
		Note: Shell variable is vimshell buffer local.
		
		To assign to environment variables, Capitalize variable name
		head.
>
		vimshell% let $Hoge = $hoge
<
		Differnt from other shells, "=" with spaces is valid.
		The {expression} is Vim script expression.
		But, you must add prefix "$" in variable name head.
		Executed status is write in "$$status".
		The prefix "$$" means vimshell internal variables.

sexe {command}					*vimshell-special-sexe*
		Execute {command} in 'shell'. If the command is wrong in
		vimshell, you can use this command.
		Note: Must be set 'shell' and shell options.
		Note: In windows, appears DOS window.

vexe {expression}				*vimshell-special-vexe*
		Execute {expression} as Vim script statement and prints
		outputs.
		
		You can use prefix ":" instead of vexe.
		Note: If you use ":", vimshell do not parse anything.
		
		Example:
>
		:ls
		:e {some_file}
<
==============================================================================
ALTER COMMAND					*vimshell-alter-command*

Vimshell supports altercmd. Altercmd is like abbrev alias.
Original altercmd plugin is here: [http://github.com/kana/vim-altercmd]

To use altercmd, call |vimshell#altercmd#define|function in vimshell buffer.
Usually, used in autocmd FileType.
>
	autocmd FileType vimshell
	\ call vimshell#altercmd#define('g', 'git')
<
==============================================================================
HOOK							*vimshell-hook*

Vimshell has not function feature, but can call hook function in hook points.
So If you learned Vim script and vimshell, customizable vimshell.

Next examples set hook in "chpwd". This hook execute ls internal command when
current directory is changed.
>
	autocmd FileType vimshell
	\ call vimshell#hook#add('chpwd', 'my_chpwd', 'g:my_chpwd')
	
	function! g:my_chpwd(args, context)
		call vimshell#execute('ls')
	endfunction
<
Default hook points are below. Hook functions arguments are {args} and
{context}.  {args} is arguments list, {context} is context information.  But
some functions arguments is {cmdline}.

chpwd							*vimshell-hook-chpwd*
		This hook called when changed vimshell current directory.
		The first argument is new current directory.

preparse					*vimshell-hook-preparse*
		This hook called when before parse command line.
		The first argument is {cmdline}. {cmdline} is command line
		string.  And returns changed command line string.

preexec						*vimshell-hook-preexec*
		This hook called when after alias parsed and before execute
		command line.
		The first argument is {cmdline}. {cmdline} is command line
		string.  And returns changed command line string.

postexec					*vimshell-hook-postexec*
		This hook called when after execute command line.
		The first argument is {cmdline}. {cmdline} is executed command
		line string.

emptycmd					*vimshell-hook-emptycmd*
		This hook called when cmdline is empty.
		The first argument is {cmdline}. {cmdline} is command line
		string.  And returns changed command line string.

notfound					*vimshell-hook-notfound*
		This hook called when the command is not found.
		The first argument is {cmdline}. {cmdline} is command line
		string.  And returns changed command line string.

preprompt					*vimshell-hook-preprompt*
		This hook called when after execute command line and before
		display prompt.

preinput					*vimshell-hook-preinput*
		This hook called when after user input.
		The first argument is {input}. {input} is user input string.
		And returns changed input string.
		Note: This hook is usually used in interactive buffer.

postinput					*vimshell-hook-postinput*
		This hook called when after executed user input.
		The first argument is {input}. {input} is user input string.
		Note: This hook is usually used in interactive buffer.

postexit					*vimshell-hook-postexit*
		This hook called when after (external) command exit.
		The first argument is {command}. {command} is executed command
		name. The second argument is {cmdline}. {command} is executed
		command line. You can get exit value by
		"b:vimshell.system_variables['status']".
		Note: This hook is usually used in interactive buffer.
		Note: The buffer may be deleted(or closed) in interactive
		buffer.

To analyze command line, use |vimproc#parser#split_args()|or
|vimproc#parser#split_args_through()|. These functions arguments are the
command line string. |vimproc#parser#split_args()| evals quoted string, but
|vimproc#parser#split_args_through()| remains quoted string.
Note: These functions do not analyze ";", "&&", "||", pipes and redirection.

==============================================================================
TIPS							*vimshell-tips*

directory stack				*vimshell-tips-directory-stack*
		Vimshell supports directory stack like bash or zsh. And
		auto_pushd automatically.  So, pushd command does not exist.
		To view directory stack, use |vimshell-internal-dirs|.
		To cd from directory stack, use |vimshell-internal-popd|.
		"cd -" is also supported.

auto_cd						*vimshell-tips-auto_cd*
		Vimshell supports auto_cd like zsh. If you execute with a
		directory name, vimshell moves to the current directory.
		Note: The setting is nothing.

block							*vimshell-tips-block*
		Vimshell supports Block.
>
		vimshell% echo /hoge/piyo/{hoge,hogera}
		-> /hoge/piyo/hoge /hoge/piyo/hogera
<
		And supports expanding numbers feature.
>
		vimshell% echo {00..09}
		-> 00 01 02 03 04 05 06 07 08 09
<
wild card					*vimshell-tips-wildcard*
		Vimshell supports wildcard. If wildcard files are not found,
		an error is occured.
>
		vimshell% ls *.htm
<
		Ignore pattern is supported.
>
		vimshell% ls *~*.htm
<
backquote					*vimshell-tips-backquote*
		You can use command output as arguments.
>
		vimshell% echo `ls`
<
		Backquote works in double quoted string.
>
		vimshell% python -c "`curl -fs https://gist.github.com/raw/4349265/sudden-vim.py`"
<
		And embed Vim script expression.
>
		vimshell% echo `=3`
<
fakecygpty					*vimshell-tips-fakecygpty*
		fakecygpty connects Windows pipes to Cygwin pty.
		Note: This command is only on Windows.
		Following command is to connect to Cygwin ssh command.
>
		> fakecygpty ssh
<
		fakecygpty original source code is in Meadow. But I distribute
		the source.
		http://github.com/Shougo/fakecygpty
		To compile the source code, execute the command below.
>
		$ gcc fakecygpty.c -o fakecygpty.exe
<
		And put fakecygpty command in $PATH directory.
>
encoding					*vimshell-tips-encoding*
		If you set 'encoding' manually on Windows environment,
		multibyte characters may be broken.
		But some commands on Windows are using "utf8" characters.
		If you use that commands, use command "--encoding" option.
>
		vimshell% iexe --encoding=utf8 ghci
<
environment-variables-execution
			*vimshell-tips-environment-variables-execution*
		To execute commands with changing environment variables like
		sh's "env=value command" syntax, you can use "env" command.
		Example:
>
		:call vimproc#system('env GIT_EDITOR= git commit')
<
auto-jump
			*vimshell-tips-auto-jump*
		You can use auto jump behavior by using alias.
		Example:
>
    		call vimshell#set_alias('j', ':Unite -buffer-name=files
          \ -default-action=lcd -no-split -input=$$args directory_mru')
<
==============================================================================
UNITE SOURCES					*vimshell-unite-sources*

				*vimshell-unite-source-vimshell-history*
vimshell/history
		Nominates vimshell histories as candidates. This source is
		also available on interactive buffer. This source is used in
		|unite#sources#vimshell_history#start_complete()|.
		Note: Default mapping is <C-l>.

		Exmaple:
>
		inoremap <buffer> <expr><silent> <C-l>  unite#sources#vimshell_history#start_complete()
<
			*vimshell-unite-source-vimshell-external_history*
vimshell/external_history
		Nominates external shell histories as candidates. This source
		is also available in interactive buffer. This source is used
		in |unite#sources#vimshell_history#start_complete()|.
		Note: Edit histories is invalid.
		Vimshell searches external history path from $SHELL
		automatically.  You can set external history path
		|g:unite_source_vimshell_external_history_path|.

kind actions:

vimshell/history		*vimshell-unite-action-vimshell-history*
	execute		Execute history.
			If you selected several histories, it joins with "; ".
	edit		Edit history.
	delete		Delete history.

==============================================================================
CREATE PLUGIN					*vimshell-create-plugin*

In this clause, I comment on a method to make plugin of vimshell.  The
ability of vimshell will spread by creating plugin by yourself.

You can add a new vimshell command easily just by adding a plugin file under
autoload/internal/ directory; vimshell reads *.vim files there as internal
command.

A tutorial is available (in Japanese.)
http://yomi322.hateblo.jp/entry/2013/01/13/141003


==============================================================================
FAQ						*vimshell-faq*

Q: I want to yank text without escape sequences.

A: You can use |concealedyank.vim| plugin.
https://github.com/chikatoike/concealedyank.vim
<Plug>(operator-concealedyank) yanks text without concealed text.
>
	xmap Y <Plug>(operator-concealedyank)
<

Q: I want to add paths to $PATH.

A: You can add them by writing a line like below in .vimshrc.
Note: That any Environment constant inside the double quotes will not be
unfold.
>
	let $PATH="~/bin:/local/usr/bin:/".$PATH
<

==============================================================================
CHANGELOG						*vimshell-changelog*

2013-03-02
- Version 10.0 development is started.

------------------------------------------------------------------------------
ChangeLog 9.2

2013-03-02
- Fixed vimshell#cd().

2013-02-11
- Fixed update behavior.
- Fixed bg command.

2013-02-10
- Fixed parse options.

2013-02-09
- Improved vexe behavior.
- Fixed vimshell_complete source.

2013-02-02
- Changed default_action in vimshell/history kind.

2013-01-31
- Improved <Plug>(vimshell_interrupt) behavior.

2013-01-21
- Improved error output.
- Fixed error syntax patterns.

2013-01-20
- Improved append histories.
- Improved vexe behavior.
- Improved print error string behavior.

2013-01-17
- Simplify history execution behavior.
- Added g:vimshell_enable_transient_user_prompt option.
- Improved <Plug>(vimshell_enter) behavior.

2013-01-15
- Added -project option.

2013-01-13
- Improved restore current directory behavior.

2013-01-12
- Improved g:vimshell_interactive_encodings behavior.

2013-01-11
- Don't set wrap option.

2013-01-06
- Skip completion inner quote.

2013-01-02
- Improved set highlight.
- Improved documentation.

2013-01-01
- Fixed vimshell_complete behavior.

2012-12-29
- Improved set syntax timing.

2012-12-25
- Set UTF-8 in fakecygpty.
- Fixed output for carriage return.

2012-12-21
- Fixed :VimShellSendString behavior.

2012-12-02
- Fixed auto_cd behavior.

2012-11-17
- Fixed for skip next complete.

2012-10-26
- Fixed error message on exit.

2012-10-23
- Fixed check of autochdir.

2012-10-21
- Improved hangup behavior.
- Renamed vimshell#interactive#send_string() to vimshell#interactive#send()

2012-10-20
- Added postexit hook.

2012-10-19
- Fixed get_history_path().

2012-10-16
- Improved command search behavior.

2012-10-13
- Fixed neocomplcache check.
- Fixed source internal command.

2012-10-02
- Added unite__new_candidate action.

2012-09-27
- Fixed multiple iexe problem.

2012-09-24
- Fixed sexe error.
- Optimized load commands.

2012-09-23
- Improved get_cursor_filename pattern.

2012-09-19
- Added FAQ section.

2012-09-13
- Added Tips.

2012-09-11
- Improved set editor variables.

2012-09-09
- Improved send string.
- Improved :VimShellSendString behavior.

2012-09-08
- Fixed interactive freeze problem(test).
- Fixed nomodifiable errors.

2012-09-02
- Improved to open buffer.
- Renamed vimshell#switch_shell().

2012-08-31
- Added vimshell/zsh_complete source(imcomplete).
- Added condition check.
- Improved vimshell/zsh_complete source candidates.
- Added <Plug>(vimshell_zsh_complete) keymapping.

2012-08-28
- Added vimshell#interactive#send_string().
- Improved documentation.
- Improved vimshell#interactive#quit_buffer().

2012-08-26
- Improved switch vimshell behavior.

2012-08-22
- Added depends.

2012-08-21
- Improved :VimShellSendString behavior.
- Fixed <Plug>(vimshell_clear) behavior.
- Fixed switch vimshell behavior.
- Fixed for interactive bufnr.
- Fixed for :VimShellSendString.
- Fixed undo point.

2012-08-20
- Improved :VimShellSendString behavior.
- Fixed :VimShellSendString behavior.

2012-08-18
- Fixed for internal commands.
- Use vimproc#util#iconv().

2012-08-15
- Improved postfix.
- Improved loaded check.
- Fixed for password pattern.

2012-08-14
- Version 9.2 development is started.

==============================================================================
vim:tw=78:ts=8:ft=help:norl:noet:fen:isk+=-:
